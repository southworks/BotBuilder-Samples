# Azure Bot

ChatBot built with Bot Composer V2.0.0

Currently, the template is verified to work with the following version:
node -v : 12.14.0
npm -v : 6.14.4

<!-- Ensure both urls contain branch name -->

[![Build Status](https://vap-jenkins.optum.com/job/AZURE/job/BOT/job/itss-fcsi-bot-services/job/master/badge/icon)](https://vap-jenkins.optum.com/job/AZURE/job/BOT/job/itss-fcsi-bot-services/job/master/)

## Bot Setup

The following steps are recommended but not necessary during initial deployment

- Update Optumfile with necessary credentials (As needed)
- Update Jenkinsfile to have the correct approvers during prod/pilot deployment
- Update Jenkinsfile to have the correct scarProjectVersion to track fortify scan history and debug. Follow this [Wiki](https://github.optum.com/advanced-development/CAIP/wiki/Create-new-application-in-SCAR-portal) to create new scar project. Then set uploadToScar to true

**IMPORTANT**
Run the following commands to set up for Bot Composer Application

```cli
npm install
```

Run this command if you have azure cli set up and wish to populate the application settings with dev environment credentials. This can be skipped and the credentials can be manually added from within Bot Composer Application under settings. The values can be found in azure KeyVault. The URL of these values can be found in table storage, under the sttfstateva\<env\> storage account, in the botresources table.

```cli
npm run setup
```

## Publishing (CI/CD using Branching)

For more detailed information, reference the [CICD Wiki](https://github.optum.com/advanced-development/CAIP/wiki/Branching-Strategy-and-CI-CD)

Deployment to **dev** environment happens on branches with names prefixed with **feature/US1234567**, where US1234567 is the user story. The recommendation is to have a short name after the prefix for quick description (i.e. feature/US1234567_authentication). Botium tests are skipped for these branches.

Deployment to **qa** environment happens on **master** branch. This is a protected branch which feature branches merge into. The first run of master branch does not deploy, it is only meant to satisfy sonarqube's need to have an initial master branch.

Deployment to **stage** environment happens on branches with names matching **release/0.1**. The version number can be single or double digits (i.e. 0.1 or 1.23). Builds are saved to JFrog Artifactory regardless of job success status. The saved zip follows the format **release-1-2-3** where the first 2 digits are from release version and the last digit is the build number.

Deployment to **prod** and **pilot** environment is done through release branches. Once a release branch job is created, the branch can then be trigger via parameterized build. Two input fields are necessary, **VERSION** is the intended build number and **TARGET_ENVIRONMENT** is the intended environment.

## Building and Publishing

Opening the repository in Bot Composer gives you the ability to build dialog. Onces the repository is connected to Jenkins, simply pushing to repository on master branch should publish. The publishing script can also be called manually from local with azure cli.

## Testing

Unit tests fall under **\_\_tests\_\_** folder. Unit tests should be added for any additional custom codes beyond what is generated by Bot Composer. Unit tests can be ran with the following command.

```cli
npm run test
```

Automated tests (Dialog tests) are under **\_\_spec\_\_** folder. To add more tests, follow tutorials on Botium and Directline3 connectors for Botium. Integration tests will be ran in every non-prod (prod/pilot) deploying environment. Smoke tests will be ran for prod and pilot.

Run the following command for the entire test suite.

```cli
npm run test:dialog
```

Run the following command for smoke tests.

```cli
npm run test:dialog-smoke
```

For local dialog testing using botium, substitute **botium.json** with the following script.
Ensure [offline-directline](https://github.com/ryanvolum/offline-directline) is running on port 3000 and connecting to the correct bot endpoint.

```json
{
  "botium": {
    "Capabilities": {
      "PROJECTNAME": "itss-fcsi-bot",
      "WAITFORBOTTIMEOUT": "30000",
      "CONTAINERMODE": "directline3",
      "DIRECTLINE3_DOMAIN": "http://localhost:3000/directline",
      "DIRECTLINE3_SECRET": "local",
      "DIRECTLINE3_WEBSOCKET": false,
      "DIRECTLINE3_POLLINGINTERVAL": 1000,
      "DIRECTLINE3_HANDLE_ACTIVITY_TYPES": "message,conversationUpdate",
      "DIRECTLINE3_WELCOME_ACTIVITY": {
        "type": "conversationUpdate",
        "membersAdded": [{ "id": "1" }],
        "recipient": { "id": "2" }
      }
    },
    "Sources": {},
    "Envs": {}
  }
}
```

## Custom Actions

To include remote custom actions, run npm install on the package and then run the following command to merge schemas. **Note** if you have a _generated_ directory, the schema merge will throw errors.

```bash
npm run build:schema
```

To build local custom actions you can reference the Microsoft [example](https://github.com/microsoft/BotBuilder-Samples/tree/main/experimental/adaptive-runtime-packages/multiply-dialog-package). Pulling this project into a folder in the root directory of your bot and run the following command (Assuming your folder is called customaction). Then merge schema as before.

```bash
npm install ./customaction
```

Lastly, to make the custom action available to Bot Composer, modify _appsettings.json_ by adding an object of the following format to runtimeSettings/components.

```json
{
  "name": "@advanceddevelopment/caip-custom-actions"
}
```

## Note

For botium tests, it is best to end convo (not partial convo) with #end as the last bot response. Otherwise tailing/unchecked dialog (expect 1 response but got 2) will overflow into the next conversation.

QnA Maker has a default score threshold of 0.3, this value can be updated by modifying **templates/appsettings.json.template**.
